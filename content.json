{"meta":{"title":"XiaoQiangYu","subtitle":"","description":"","author":"XiaoQiangYu","url":"https://itqiangyu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-09T03:11:27.038Z","updated":"2020-07-09T03:11:27.038Z","comments":true,"path":"404.html","permalink":"https://itqiangyu.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 向博主反馈问题"},{"title":"Java","date":"2020-06-06T15:50:49.000Z","updated":"2020-07-08T05:00:42.513Z","comments":true,"path":"Java/index.html","permalink":"https://itqiangyu.github.io/Java/index.html","excerpt":"","text":"Java 本系列之主要来写一些Java基础的知识 Start Learning Java Basic"},{"title":"Spring","date":"2020-06-06T15:50:49.000Z","updated":"2020-07-09T02:53:54.544Z","comments":true,"path":"Spring/index.html","permalink":"https://itqiangyu.github.io/Spring/index.html","excerpt":"","text":"Spring 本系列之主要来写一些Spring基础的知识 Start Learning Spring Basic"},{"title":"个人简介","date":"2020-07-09T03:58:44.388Z","updated":"2020-07-09T03:58:44.388Z","comments":true,"path":"about/index.html","permalink":"https://itqiangyu.github.io/about/index.html","excerpt":"","text":"一只爱生活的小猪 联系博主"},{"title":"留言板","date":"2020-06-05T15:25:38.000Z","updated":"2020-07-09T03:57:36.404Z","comments":true,"path":"board/index.html","permalink":"https://itqiangyu.github.io/board/index.html","excerpt":"","text":"联系博主"},{"title":"所有标签","date":"2020-07-09T02:48:30.216Z","updated":"2020-06-06T04:40:11.000Z","comments":true,"path":"tags/index.html","permalink":"https://itqiangyu.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-06-06T09:26:25.560Z","updated":"2020-06-06T04:40:11.000Z","comments":false,"path":"friends/index.html","permalink":"https://itqiangyu.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2020-06-06T09:26:09.397Z","updated":"2020-06-06T04:40:11.000Z","comments":true,"path":"categories/index.html","permalink":"https://itqiangyu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Contributors「鸣谢」","date":"2020-06-06T09:26:16.268Z","updated":"2020-06-06T04:40:11.000Z","comments":true,"path":"contributors/index.html","permalink":"https://itqiangyu.github.io/contributors/index.html","excerpt":"","text":"特别鸣谢 hexo 开发者和 volantis 开发者！ Hexo volantis"},{"title":"Spring原理","date":"2020-07-08T03:12:37.000Z","updated":"2020-07-08T03:13:29.813Z","comments":true,"path":"Spring/basic/SpringBasic.html","permalink":"https://itqiangyu.github.io/Spring/basic/SpringBasic.html","excerpt":"Spring原理","text":"Spring原理 Spring原理讲解1、什么是Spring框架，Spring框架主要包含哪些模块​ Spring是一个开源框架，Spring是一个轻量级的Java 开发框架。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的full-stack(一站式) 轻量级开源框架。 2、Spring框架的优势​ 1、Spring通过DI、AOP和消除样板式代码来简化企业级Java开发 ​ 2、Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL ​ 3、低侵入式设计，代码的污染极低 ​ 4、独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺 ​ 5、Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦 ​ 6、Spring的AOP允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用 ​ 7、Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问 ​ 8、Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部 3、IOC和DI是什么？​ 控制反转是就是应用本身不负责依赖对象的创建和维护,依赖对象的创建及维护是由外部容器负责的,这样控制权就有应用转移到了外部容器,控制权的转移就是控制反转。 ​ 依赖注入是指:在程序运行期间,由外部容器动态地将依赖对象注入到组件中如：一般，通过构造函数注入或者setter注入。 4、描述下Spring IOC容器的初始化过程​ Spring IOC容器的初始化简单的可以分为三个过程： ​ 第一个过程是Resource资源定位。这个Resouce指的是BeanDefinition的资源定位。这个过程就是容器找数据的过程，就像水桶装水需要先找到水一样。 ​ 第二个过程是BeanDefinition的载入过程。这个载入过程是把用户定义好的Bean表示成Ioc容器内部的数据结构，而这个容器内部的数据结构就是BeanDefition。 ​ 第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程就是将前面的BeanDefition保存到HashMap中的过程。 5、BeanFactory 和 FactoryBean的区别？ BeanFactory是个Factory，也就是IOC容器或对象工厂，在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的，提供了实例化对象和拿对象的功能。 使用场景： 从Ioc容器中获取Bean(byName or byType) 检索Ioc容器中是否包含指定的Bean 判断Bean是否为单例 FactoryBean是个Bean，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。 使用场景 ProxyFactoryBean 6、BeanFactory和ApplicationContext的异同 相同： Spring提供了两种不同的IOC 容器，一个是BeanFactory，另外一个是ApplicationContext，它们都是Java interface，ApplicationContext继承于BeanFactory(ApplicationContext继承ListableBeanFactory。 它们都可以用来配置XML属性，也支持属性的自动注入。 而ListableBeanFactory继承BeanFactory)，BeanFactory 和 ApplicationContext 都提供了一种方式，使用getBean(&quot;bean name&quot;)获取bean。 不同： 当你调用getBean()方法时，BeanFactory仅实例化bean，而ApplicationContext 在启动容器的时候实例化单例bean，不会等待调用getBean()方法时再实例化。 BeanFactory不支持国际化，即i18n，但ApplicationContext提供了对它的支持。 BeanFactory与ApplicationContext之间的另一个区别是能够将事件发布到注册为监听器的bean。 BeanFactory 的一个核心实现是XMLBeanFactory 而ApplicationContext 的一个核心实现是ClassPathXmlApplicationContext，Web容器的环境我们使用WebApplicationContext并且增加了getServletContext 方法。 如果使用自动注入并使用BeanFactory，则需要使用API注册AutoWiredBeanPostProcessor，如果使用ApplicationContext，则可以使用XML进行配置。 简而言之，BeanFactory提供基本的IOC和DI功能，而ApplicationContext提供高级功能，BeanFactory可用于测试和非生产使用，但ApplicationContext是功能更丰富的容器实现，应该优于BeanFactory 7、Spring Bean 的生命周期？ 总结： （1）实例化Bean： 对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。 （2）设置对象属性（依赖注入）： 实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。 （3）处理Aware接口： 接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean： ①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值； ②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。 ③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文； （4）BeanPostProcessor： 如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。 （5）InitializingBean 与 init-method： 如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。 （6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术； 以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。 （7）DisposableBean： 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法； （8）destroy-method： 最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。 8、Spring AOP的实现原理？​ Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 ​ Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 ​ 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。 9、Spring 是如何管理事务的？​ Spring事务管理主要包括3个接口，Spring的事务主要是由它们(PlatformTransactionManager，TransactionDefinition，TransactionStatus)三个共同完成的。 1. PlatformTransactionManager：事务管理器--主要用于平台相关事务的管理 主要有三个方法： commit 事务提交； rollback 事务回滚； getTransaction 获取事务状态。 2. TransactionDefinition：事务定义信息--用来定义事务相关的属性，给事务管理器PlatformTransactionManager使用 这个接口有下面四个主要方法： getIsolationLevel：获取隔离级别； getPropagationBehavior：获取传播行为； getTimeout：获取超时时间； isReadOnly：是否只读（保存、更新、删除时属性变为false--可读写，查询时为true--只读） 事务管理器能够根据这个返回值进行优化，这些事务的配置信息，都可以通过配置文件进行配置。 3. TransactionStatus：事务具体运行状态--事务管理过程中，每个时间点事务的状态信息。 例如它的几个方法： hasSavepoint()：返回这个事务内部是否包含一个保存点， isCompleted()：返回该事务是否已完成，也就是说，是否已经提交或回滚 isNewTransaction()：判断当前事务是否是一个新事务 声明式事务的优缺点： 优点：不需要在业务逻辑代码中编写事务相关代码，只需要在配置文件配置或使用注解（@Transaction），这种方式没有侵入性。 缺点：声明式事务的最细粒度作用于方法上，如果像代码块也有事务需求，只能变通下，将代码块变为方法。 10、Spring 的不同事务传播行为有哪些，干什么用的？ 11、Spring 中用到了那些设计模式？ 代理模式—在AOP中被用的比较多。 单例模式—在spring配置文件中定义的bean默认为单例模式。 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 工厂模式—BeanFactory用来创建对象的实例。 适配器--spring aop 装饰器--spring data hashmapper 观察者-- spring 事件驱动模型 回调--Spring Aware回调接口 12、Spring如何解决循环依赖？https://blog.csdn.net/qq_36381855/article/details/79752689 13、bean的作用域（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。 （2）prototype：为每一个bean请求提供一个实例。 （3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 （4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 14、Spring框架中有哪些不同类型的事件（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。 （2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。 （3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 （4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。 （5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。 15、Spring通知有哪些类型（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。 （2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 （3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 （4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 （5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。 16、Spring的自动装配在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。 在Spring框架xml配置中共有5种自动装配： （1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。 （2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 （3）byType：通过参数的数据类型进行自动装配。 （4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。 （5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。 基于注解的方式： 使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean： 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据； 如果查询的结果不止一个，那么@Autowired会根据名称来查找； 如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。 @Autowired可用于：构造函数、成员变量、Setter方法 注：@Autowired和@Resource之间的区别 (1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。 (2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。"}],"posts":[{"title":"HandlerAdapter","slug":"SpringMVC/HandlerAdapter","date":"2020-07-05T13:00:16.000Z","updated":"2020-07-05T14:43:39.476Z","comments":true,"path":"ckce9knpn000g34vm4baw2s0j/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpn000g34vm4baw2s0j/","excerpt":"HandlerAdapter","text":"HandlerAdapter ​ HandlerMapping将方法映射到URL，因此DispatcherServlet知道特定请求应该调用哪个方法。然后DispatcherServlet使用HandlerAdapter来调用该方法。 ​ SpringMVC通过HandlerMapping获取到可以处理的handler，这些handler的类型各不相同，对请求的预处理，参数获取都不相同，最简单的做法是根据不同的handler类型，做一个分支处理，不同的handler编写不同的代码。 ​ 这样的问题是很明显的，分支判断复杂，代码庞大，不符合单一职责原则。如果要增加一种handler类型，需要修改代码增加分支处理，违反了开闭原则。DispatcherServelt与多个handler发生了交互，违反迪米特法则。 ​ 而使用适配器模式，就可以很好的解决这个问题： ​ 不直接对handler进行处理，而是将handler交给适配器HandlerAdapter去处理，这样DispatcherServlet交互的类就只剩下一个接口，HandlerAdapter，符合迪米特法则，尽可能少的与其他类发生交互； ​ 将handler交给HandlerAdapter处理后，不同类型的handler被对应类型的HandlerAdapter处理，每个HandlerAdapter都只完成单一的handler处理，符合单一职责原则； ​ 如果需要新增一个类型的handler，只需要新增对应类型的HandlerAdapter就可以处理，无需修改原有代码，符合开闭原则。 ​ 这样，不同的handler的不同处理方式，就在HandlerAdapter中得到了适配，对于DispatcherServlet来讲，只需要统一的调用HandlerAdapter的handle()方法就可以了，无需关注不同handler的处理细节。 设计模式的原则 1.单一职责原则 一个类只完成单一的功能，粒度越小越好 ​ 2.开闭原则​ 对扩展开放，对修改关闭。​ 一个类开发完成后，应当可以通过扩展的方式实现新的功能，而不是通过修改原有类来达到目的。 ​ 3.里氏替换原则​ 所有引用父类的地方都可以透明的使用其子类 ​ 4.依赖倒置原则​ 抽象不应该依赖于细节，细节应该依赖于抽象。​ 应该针对接口或抽象类编程，而不是针对具体的实现编程 ​ 5.接口隔离原则​ 接口的划分应该更细致，使用多个功能单一的接口，而不是将所有的功能放到一个接口中实现，客户端不应该去依赖它所不需要的接口方法。 ​ 6.迪米特法则​ 一个类应尽可能少的与其他类进行交互。降低耦合。 向博主反馈问题","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://itqiangyu.github.io/categories/SpringMVC/"}],"tags":[{"name":"Adapter","slug":"Adapter","permalink":"https://itqiangyu.github.io/tags/Adapter/"}]},{"title":"SpringMVC流程","slug":"SpringMVC/SpringMVC流程","date":"2020-07-05T13:00:16.000Z","updated":"2020-07-08T03:30:01.450Z","comments":true,"path":"ckce9knpq000i34vmc6yhagmu/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpq000i34vmc6yhagmu/","excerpt":"SpringMVC执行流程","text":"SpringMVC执行流程 123456789101112&lt;!--SpringMVC用到的jar包--&gt; &lt;!--spring-web提供监听器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; SpringMVC执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC对的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 当请求进来，执行 DispatcherServlet.doDispatch(HttpServletRequest request，HttpServletResponse response)方法，列举一些比较重要的方法 12345678910111213141516171819202122232425262728293031323334/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */ protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HandlerExecutionChain mappedHandler = null; ModelAndView mv = null; .... // Determine handler for the current request. 获取handler，返回HandlerExecutionChain执行链 mappedHandler = getHandler(processedRequest); .... // Determine handler adapter for the current request. 获取适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); .... // Actually invoke the handler. 根据适配器，执行目标方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); .... &#125; HandlerMapping为处理器映射器，由DispathcerServlet调用getHandler(processedRequest)方法，最终返回HandlerExecutionChain执行链，里面包括处理器handler，拦截器filter等等 HandlerMapping是根据请求URl查找Handler，SpringMVC默认的HandlerMapping在文章后面 若寻找到handler，将其封装到HandlerExecutionChain返回 若寻找不到handler，看是否配置了 &lt;mvc:default-servlet-handler /&gt; 标签，若没配置，则直接返回404，并且控制台打印：WARN ework.web.servlet.PageNotFound - No mapping for GET /account/test 若配置了&lt;mvc:default-servlet-handler /&gt; 标签，则使用默认的HandlerMapping：SimpleUrlHandlerMapping **，返回HandlerExecutionChain执行链，里面的handler为：org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler**。接着会去寻找静态资源，若找不到就404 接下来确定当前请求的处理程序适配器，根据handler去确定适配器，getHandlerAdapter(mappedHandler.getHandler())，默认的HandlerMapping在文章后面 到执行处理请求的方法：ha.handle 先执行拦截器的preHandler方法 调用目标Handler的目标方法得到返回值ModelAndView对象，反射执行方法看是否存在异常 如果存在异常，则由HandlerExceptionResolver组件处理异常，得到新的ModelAndView对象 最终由试图解析器ViewResolver组件解析ModelAndView对象得到View 渲染视图 调用拦截器的afterCompletion方法 调用拦截器的postHandler方法 SpringMVC 默认的映射器以及适配器默认的处理器映射器HandlerMapping： org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping org.springframework.web.servlet.handler.SimpleUrlHandlerMapping（注意: 该映射器HandlerMapping是配置 &lt;mvc:default-servlet-handler /&gt; 标签, 返回默认的DefaultServletHttpRequestHandler, 如果DispatcherServlet没用找到请求对应的处理器, 则会返回这个handler, 这个handler可以对静态资源进行处理） 默认的处理器适配器Adapter，主要的作用是执行处理请求的方法： org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 向博主反馈问题","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://itqiangyu.github.io/categories/SpringMVC/"}],"tags":[]},{"title":"快速返回上次查看代码的位置","slug":"idea/快速返回上次查看代码的位置","date":"2020-07-03T05:39:16.000Z","updated":"2020-07-03T14:20:52.105Z","comments":true,"path":"ckce9knpo000h34vm30y35dc7/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpo000h34vm30y35dc7/","excerpt":"快速返回上次查看代码的位置","text":"快速返回上次查看代码的位置 快速返回上次查看代码的位置在IDEA中可以使用快捷键返回，默认是：ctrl + alt + 方向键 向博主反馈问题","categories":[{"name":"idea","slug":"idea","permalink":"https://itqiangyu.github.io/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://itqiangyu.github.io/tags/idea/"}]},{"title":"aop","slug":"Spring/aop","date":"2020-07-02T06:35:37.000Z","updated":"2020-07-02T06:45:42.535Z","comments":true,"path":"ckce9knpe000c34vm8llb6zsg/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpe000c34vm8llb6zsg/","excerpt":"aop定义及源码","text":"aop定义及源码 什么是aop？​ 与00P对比，面向切面,传统的00P开发中的代码逻辑是至上而下的,在这些至上而下的过程中会产生一些横切性的问题 ,这些横切性的问题和我们的主业务逻辑关系不大,会散落在代码的各个地方,造成难以维护, AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高。 应用场景 日志记录 权限认证 效率检查 事务管理 ............ 横切性问题：相对于oop而言，一些跟业务逻辑没有关系，会散落再业务逻辑的各个地方这些代码，这些会造成代码很难维护。 oop跟多关注的是业务逻辑的处理，而aop关注的是切面的处理 向博主反馈问题","categories":[{"name":"Spring","slug":"Spring","permalink":"https://itqiangyu.github.io/categories/Spring/"}],"tags":[{"name":"aop","slug":"aop","permalink":"https://itqiangyu.github.io/tags/aop/"}]},{"title":"bean生命周期源码","slug":"Spring/bean生命周期","date":"2020-07-01T14:20:27.000Z","updated":"2020-07-08T04:24:08.073Z","comments":true,"path":"ckce9knpf000d34vme3rq0ari/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpf000d34vme3rq0ari/","excerpt":"bean生命周期源码","text":"bean生命周期源码 向博主反馈问题","categories":[{"name":"Spring","slug":"Spring","permalink":"https://itqiangyu.github.io/categories/Spring/"}],"tags":[]},{"title":"类的实例化顺序","slug":"Java/basics/class_instantiation","date":"2020-06-30T13:40:38.000Z","updated":"2020-06-30T13:50:36.904Z","comments":true,"path":"ckce9knqu001l34vm6p06cjnq/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqu001l34vm6p06cjnq/","excerpt":"类的实例化顺序？","text":"类的实例化顺序？ java类的实例化顺序 1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行 2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行 3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行 4． 父类构造方法 5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行 6． 子类构造方法 总结：父类静态成员和静态代码块-&gt;子类静态成员和静态代码块-&gt;父类非静态成员和非静态代码块-&gt;父类构造方法-&gt;子类非静态成员和非静态代码块-&gt;子类构造方法 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"class","slug":"class","permalink":"https://itqiangyu.github.io/tags/class/"}]},{"title":"Socket通讯原理","slug":"计算机网络基础/Socket","date":"2020-06-30T09:16:53.000Z","updated":"2020-06-30T12:09:01.152Z","comments":true,"path":"ckce9knqd001c34vm4mxg4djd/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqd001c34vm4mxg4djd/","excerpt":"什么是TCP/IP、UDP？ Socket在哪里？ Socket是什么？","text":"什么是TCP/IP、UDP？ Socket在哪里？ Socket是什么？ 什么是TCP/IP、UDP？​ TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。 ​ 这里有一张图，表明了这些协议的关系，如如下图1所示： ​ TCP/IP协议族包括运输层、网络层、链路层。现在你知道TCP/IP与UDP的关系了吧。 Socket在哪里呢？​ 在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。如下图2所示： Socket是什么呢？​ Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 你会使用它们吗？​ 前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。 ​ 例如：一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景解释了这工作原理，也许TCP/IP协议族就是诞生于生活中。 ​ 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 ​ 我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页 时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠Socket？那什么是 Socket？Socket的类型有哪些？还有Socket的基本函数，这些都是本文想介绍的。本文的主要内容如下： 什么是Socket？​ 上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。 网络中进程之间是如何通信的？ 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Sun RPC） ​ 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程的PID来唯一标识一个进程，但是在网络中这是不可行的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“IP地址”可以表示这个网络中的主机，而传输层的“协议 + 端口”可以唯一表示主机中的应用程序（进程）。这样利用三元组（IP地址、协议、端口）就可表示网络主机的进程，网络中的进程用就可以利用这个标志与其他进程进行交互。 ​ 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（Socket）和UNIX System V的TLI（淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用小恒徐都是采用Socket，而现在又是网络时代，网络中进程通信时无处不在（“一切皆Socket”）。 TCP/IP协议概念： ​ TCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。 ​ 它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。 ​ TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话： 123[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”[Shake 2] 套接字B：“好的，我这边已准备就绪。”[Shake 3] 套接字A：“发送连接请求。” TCP数据报结构，如下图1-1所示： 带阴影的几个字段需要重点说明一下： 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：建立一个新连接。 FIN：断开一个连接。 连接的建立（三次握手）：使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2： ​ 客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求​ 这时客户端发起请求： 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。 服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。 服务器将数据包发出，进入SYN-RECV状态 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。 接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。 客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。 至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。 TCP四次握手断开连接​ 建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。 断开连接需要四次握手，可以形象的比喻为下面的对话： 12345[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”等待片刻后……[Shake 3] 套接字B：“我准备好了，可以断开连接了。”[Shake 4] 套接字A：“好的，谢谢合作。” 下图演示了客户端主动断开连接的场景： ​ 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求： 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 OSI模型TCP/IP对OSI的网络模型层进行了划分如下： TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 传输层：TCP，UDP 网络层：IP，ICMP，OSPF，EIGRP，IGMP 数据链路层：SLIP，CSLIP，PPP，MTU 每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的 参考文章链接： https://blog.csdn.net/jiushimanya/article/details/82684525 https://www.jianshu.com/p/066d99da7cbd 向博主反馈问题","categories":[{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"https://itqiangyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"https://itqiangyu.github.io/tags/Socket/"}]},{"title":"JAVA 中的几种基本数据类型","slug":"Java/basics/data_type","date":"2020-06-30T04:49:36.000Z","updated":"2020-06-30T12:06:34.693Z","comments":true,"path":"ckce9knqx001m34vmcldpa0ff/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqx001m34vmcldpa0ff/","excerpt":"JAVA 中的几种基本数据类型是什么，各自占用多少字节。","text":"JAVA 中的几种基本数据类型是什么，各自占用多少字节。 Java共有8中基本数据类型 基本数据类型 占用空间 boolean 1/8个字节（1bit） byte 1个字节 short 2个字节 char 2个字节 int 4个字节 float 4个字节 long 8个字节 double 8个字节 其中： bit（位）：位是计算机中存储数据的最小单位，指二进制数中的一个位数，其值为“0”或“1” byte（字节）：字节是计算机存储容量的基本单位，一个字节由8位二进制数组成。在计算机内部，一个字节可以表示一个数据，也可以表示一个英文字母，两个字节可以表示一个汉字 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"Java数据类型","slug":"Java数据类型","permalink":"https://itqiangyu.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS setTimeout","slug":"js/setTimeout","date":"2020-06-27T13:40:10.000Z","updated":"2020-06-30T12:08:34.617Z","comments":true,"path":"ckce9knpu000n34vmgygqfowr/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpu000n34vmgygqfowr/","excerpt":"使用循环时，用来延迟执行方法","text":"使用循环时，用来延迟执行方法 12345678_this.data.imgs.forEach(function(e, index) &#123; // 采用闭包的方式来立即执行setTimeout，每隔500毫秒执行方法 (function(e) &#123; setTimeout(function() &#123; _this.uploadImg(e); &#125;, index * 500); &#125;)(e)&#125;); 向博主反馈问题","categories":[{"name":"js","slug":"js","permalink":"https://itqiangyu.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://itqiangyu.github.io/tags/js/"}]},{"title":"ArrayList与LinkedList","slug":"Java/List/ArrayList_LinkedList","date":"2020-06-21T01:55:31.000Z","updated":"2020-06-30T12:07:58.891Z","comments":true,"path":"ckce9knqt001k34vmg2osdekz/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqt001k34vmg2osdekz/","excerpt":"ArrayList与LinkedList主要区别","text":"ArrayList与LinkedList主要区别 ArrayList底层结构是数组 LinkedList底层结构是链表 所以主要区别是数组与链表的区别 ArrayList：基于数组数据结构 查询快，在堆（heap）内存是连续的内存空间支持随机访问 插入和删除的效率比较低，插入需要扩容，删除需要移动元素 根据内容查找元素的效率较低 LinkedList：基于链表数据结构 插入和删除的效率高，非常适合经常增加、删除操作的场景 查询在量大的时候较慢，链表查询，需要从表头或者表尾逐一遍历查询 共同点都不是线程安全的如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://itqiangyu.github.io/tags/List/"}]},{"title":"LinkedList","slug":"Java/List/LinkedList","date":"2020-06-09T05:40:26.000Z","updated":"2020-06-30T12:08:14.167Z","comments":true,"path":"ckce9knqp001g34vm34v01opl/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqp001g34vm34v01opl/","excerpt":"LinkedList实现原理","text":"LinkedList实现原理 阅读本篇文章需要数据结构 链表（双向链表） 的基础如何简单使用，创建一个LinkedList对象，并且调用add方法新增一个元素 先来看看不指定插入的位置1234public static void main(String[] args) &#123; List list = new LinkedList(); list.add(\"test\");&#125; 那么就这么两句话，它运行时是如何实现的呢？ 点击进去看源码！ 构造器，并没有执行任何的操作，只是构造一个空链表 12345/*** Constructs an empty list.*/public LinkedList() &#123;&#125; add方法，看到方法称以及注释，可知道新增节点采用的是尾插法。 123456789101112/*** Appends the specified element to the end of this list.** &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.** @param e element to be appended to this list* @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)*/public boolean add(E e) &#123; linkLast(e); return true;&#125; 再看具体任何新增节点的细节，进去看看linkLast方法 这是一个很标准的尾插法操作：先将尾节点的引用赋值给 l ，然后创建一个新节点，该节点的前驱（prev）为 l ，数据（item）为 e ，后继（next）为null 接下来判断该新增节点是否为链表的第一个节点，如果是，则将该节点的引用赋值给 first ，否则将新增节点地址赋值给l.next 1234567891011121314151617181920212223242526private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;/*** Links e as last element.*/void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 再看看指定插入的位置1234public static void main(String[] args) &#123; List list = new LinkedList(); list.add(1, \"test\");&#125; 具体方法实现 1234567891011121314151617/*** Inserts the specified element at the specified position in this list.* Shifts the element currently at that position (if any) and any* subsequent elements to the right (adds one to their indices).** @param index index at which the specified element is to be inserted* @param element element to be inserted* @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;*/public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 首先执行checkPositionIndex，校验index是否合法，具体实现 123456789101112private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/*** Tells if the argument is the index of a valid position for an* iterator or an add operation.*/private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125; 然后回判断插入的位置是否为尾节点，如果是则执行上面所说的尾插法，否则执行linkBefore方法，需要参数（E e, Node succ），而所需要的 succ 形参需要调用node方法获取到。 看node方法，根据index（索引）获取到所对应的节点。判断的方法类似二分查找法，链表查找都需要逐一遍历，所以需要判断从头节点还是尾节点开始遍历查找。 12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;/*** Inserts element e before non-null Node succ.*/void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125;/*** Returns the (non-null) Node at the specified element index.*/Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 接下来看linkBefore方法，这个也是双向链表基本的操作。 123456789101112131415/*** Inserts element e before non-null Node succ.*/void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://itqiangyu.github.io/tags/List/"}]},{"title":"ArrayList","slug":"Java/List/ArrayList","date":"2020-06-08T13:46:57.000Z","updated":"2020-06-30T12:07:46.662Z","comments":true,"path":"ckce9knqr001h34vmfva0gywf/","link":"","permalink":"https://itqiangyu.github.io/ckce9knqr001h34vmfva0gywf/","excerpt":"ArrayList实现原理","text":"ArrayList实现原理 如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素1234public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"test\");&#125; 那么就这么两句话，它运行时是如何实现的呢？ 点击进去看源码！ 当不指定数组长度时 构造器（构造函数）：此构造器没有参数，并且也没有数组初始化，就只有一句 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。问题来了，是什么时候开始初始化数组？初始化的长度是多少？带着这个问题，继续往下面看。 123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 当调用add方法时，点击进去查看源代码，在真正赋值的操作前，执行了ensureCapacityInternal，参数是 size + 1 ，size表示当前ArrayList的大小，此参数的意义是判断 size + 1 后，数组索引是否越界，所以这个方法是保证在赋值前数组索引是否越界（是否需要扩容）以及记录ArrayList结构性变化的次数： 12345678910111213141516171819/*** The size of the ArrayList (the number of elements it contains).** @serial*/private int size;/*** Appends the specified element to the end of this list.** @param e element to be appended to this list* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)*/public boolean add(E e) &#123; // 在赋值前，记录modCount（modCount，记录ArrayList结构性变化的次数）以及判断是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 点进去ensureCapacityInternal方法，上来就一个判断，这个判断是什么意思？回过头来看一下空构造器，这句话不就是判断的条件吗？ 构造器出现的 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;那么它是什么意思呢？按照字面意思是表示一种状态，当 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表采用默认的长度 DEFAULT_CAPACITY （10），以确保在第一次添加元素时要扩容的大小。 判断条件成立，执行Math.max，在DEFAULT_CAPACITY（10）和minCapacity（1）之间取最大值，以确保在第一次添加元素时要扩容的大小，获取到最大值后将它赋值给minCapacity（10），接着执行ensureExplicitCapacity方法并传入参数minCapacity，具体往后面看。 123456789101112131415161718192021222324252627/*** Default initial capacity.*/private static final int DEFAULT_CAPACITY = 10;/*** Shared empty array instance used for default sized empty instances. We* distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when* first element is added.*/private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** The array buffer into which the elements of the ArrayList are stored.* The capacity of the ArrayList is the length of this array buffer. Any* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA* will be expanded to DEFAULT_CAPACITY when the first element is added.*/transient Object[] elementData; // non-private to simplify nested class accessprivate void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 继续来看看ensureExplicitCapacity方法源码，上来就modCount++，表示ArrayList结构性变化的次数加一，接着判断数组索引是否越界（是否需要扩容）。此时，当创建ArrayList对象时，只是初始化空数组，并没有指定数组长度，所以elementData.length = 0，而minCapacity是传过来的参数10，所以该判断条件是成立的，需要执行grow方法进行扩容。 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 这里需要注意的是：minCapacity = 10，elementData.length = 0。这里不理解的还需要再回到前面去看看。 当执行到扩容语句时，此时的elementData.length = 0，所以扩容之后还是0，这个时候就有疑问了，扩容之后还是0？接下来的一个判断起到关键性的作用，也是专门判断扩容之后的长度比原来小的问题，当扩容后的长度比原先的小时，最终是按照原先的大小进行扩容，再下面就是数组copy扩容了。 123456789101112131415161718/*** Increases the capacity to ensure that it can hold at least the* number of elements specified by the minimum capacity argument.** @param minCapacity the desired minimum capacity*/private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 这里确定扩容的大小，比原来大1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 刚开始写的博客，可能表达的有点不清楚，请见谅 总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1.5倍。 当指定数组长度：12ArrayList list = new ArrayList(8);list.add(\"test\"); 结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10. 1234567891011121314151617/*** Constructs an empty list with the specified initial capacity.** @param initialCapacity the initial capacity of the list* @throws IllegalArgumentException if the specified initial capacity* is negative*/public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://itqiangyu.github.io/tags/List/"}]},{"title":"StringBuffer与StringBuilder","slug":"Java/String/StringBuffer_StringBuilder","date":"2020-06-07T04:41:39.000Z","updated":"2020-06-30T12:08:23.549Z","comments":true,"path":"ckce9knr4002334vm2lanch59/","link":"","permalink":"https://itqiangyu.github.io/ckce9knr4002334vm2lanch59/","excerpt":"StringBuffer与StringBuilder主要的区别","text":"StringBuffer与StringBuilder主要的区别 话不多说，先先看源码（JDK1.8）StringBuffer类的append方法： 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; StringBuilder类的append方法： 12345@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 明显可以看出，StringBuffer类的append方法被synchronized关键字修饰，而StringBuilder类的append方法没有被synchronized修饰。 Tips：被synchronized修改的方法或者代码块可以保证在同一时刻，只有一个线程可以执行，同时还可以保证线程的可见性。 结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。String是字符串不可变对象, StringBuffer、StringBuild,可变对象 StringBuffer线程安全,其中方法用synchronized修饰除了synchronized关键字外，StringBuffer类还多了个toStringCache成员变量，这个变量是干什么的呢？来看一下源码 123456789101112/*** A cache of the last value returned by toString. Cleared* whenever the StringBuffer is modified.*/private transient char[] toStringCache;@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 从官方字面意思来说是返回最后一次toString的缓存值，一但被修改就清除这个值。 当多个线程同时访问时，StringBuffer虽然是线程安全的，但是性能低效，所以加一个缓存来平衡一下StringBuffer的性能。 向博主反馈问题","categories":[{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"https://itqiangyu.github.io/tags/String/"}]},{"title":"MarkDown语法","slug":"MarkDown/MarkDown","date":"2020-06-06T12:32:41.000Z","updated":"2020-06-30T12:07:08.198Z","comments":true,"path":"ckce9knpt000m34vm59kj7gi6/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpt000m34vm59kj7gi6/","excerpt":"MarkDown语法基本语法","text":"MarkDown语法基本语法 标题:#空格：一级标题##空格：二级标题###空格：三级标题####空格：四级标题#####空格：五级标题######空格：六级标题 字体两边各加两个 * 是粗体 两边各加一个 * 是斜体 两边各加三个 * 是粗体加斜体 两边各加两个 ~ 波浪线 引用&quot;&gt;&quot; 空格 例如： 分割线三个&quot;---&quot;或者&quot;***&quot;是分割线 图片!加[]加()是添加图片,可以添加本地路径或网络图片地址 超链接[]加()括号里面下网络地址 列表 1点空格（1. ）：是以下列表 A B C -空格：是以下列表 A B C 表格例如：下面三行，删掉换行就是表格 名字|性别|生日 --|--|--| 张三|男|1994.1.1 名字 性别 生日 张三 男 1994.1.1 联系博主","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://itqiangyu.github.io/categories/MarkDown/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://itqiangyu.github.io/tags/MarkDown/"}]},{"title":"http与https的区别","slug":"计算机网络基础/http与https的","date":"2020-06-06T02:54:59.000Z","updated":"2020-06-30T12:04:33.648Z","comments":true,"path":"ckce9knpw000r34vm89vfa8ed/","link":"","permalink":"https://itqiangyu.github.io/ckce9knpw000r34vm89vfa8ed/","excerpt":"基本概念和主要区别","text":"基本概念和主要区别 HTTP与HTTPS的基本概念 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTP与HTTPS有什么区别？ HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 参考文章：https://www.jianshu.com/p/6db0c6dc97a9联系博主","categories":[{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"https://itqiangyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"http https","slug":"http-https","permalink":"https://itqiangyu.github.io/tags/http-https/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-06-05T15:37:08.000Z","updated":"2020-06-06T10:21:13.993Z","comments":true,"path":"ckce9knn3000434vm0ou1gtxk/","link":"","permalink":"https://itqiangyu.github.io/ckce9knn3000434vm0ou1gtxk/","excerpt":"","text":"2020/6/4 搭建hexo博客","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-04T15:37:08.000Z","updated":"2020-06-06T10:20:51.336Z","comments":true,"path":"ckce9knmx000234vmdax27wdh/","link":"","permalink":"https://itqiangyu.github.io/ckce9knmx000234vmdax27wdh/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://itqiangyu.github.io/categories/SpringMVC/"},{"name":"idea","slug":"idea","permalink":"https://itqiangyu.github.io/categories/idea/"},{"name":"Spring","slug":"Spring","permalink":"https://itqiangyu.github.io/categories/Spring/"},{"name":"Java","slug":"Java","permalink":"https://itqiangyu.github.io/categories/Java/"},{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"https://itqiangyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","permalink":"https://itqiangyu.github.io/categories/js/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://itqiangyu.github.io/categories/MarkDown/"}],"tags":[{"name":"Adapter","slug":"Adapter","permalink":"https://itqiangyu.github.io/tags/Adapter/"},{"name":"idea","slug":"idea","permalink":"https://itqiangyu.github.io/tags/idea/"},{"name":"aop","slug":"aop","permalink":"https://itqiangyu.github.io/tags/aop/"},{"name":"class","slug":"class","permalink":"https://itqiangyu.github.io/tags/class/"},{"name":"Socket","slug":"Socket","permalink":"https://itqiangyu.github.io/tags/Socket/"},{"name":"Java数据类型","slug":"Java数据类型","permalink":"https://itqiangyu.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"js","slug":"js","permalink":"https://itqiangyu.github.io/tags/js/"},{"name":"List","slug":"List","permalink":"https://itqiangyu.github.io/tags/List/"},{"name":"String","slug":"String","permalink":"https://itqiangyu.github.io/tags/String/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://itqiangyu.github.io/tags/MarkDown/"},{"name":"http https","slug":"http-https","permalink":"https://itqiangyu.github.io/tags/http-https/"}]}