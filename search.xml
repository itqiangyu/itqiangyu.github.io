<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HandlerAdapter</title>
      <link href="/ckce9unvn000hpkvmeln63gpe/"/>
      <url>/ckce9unvn000hpkvmeln63gpe/</url>
      
        <content type="html"><![CDATA[<p>HandlerAdapter</p><a id="more"></a><p>​        HandlerMapping将方法映射到URL，因此DispatcherServlet知道特定请求应该调用哪个方法。然后DispatcherServlet使用HandlerAdapter来调用该方法。</p><p>​        SpringMVC通过HandlerMapping获取到可以处理的handler，这些handler的类型各不相同，对请求的预处理，参数获取都不相同，最简单的做法是根据不同的handler类型，做一个分支处理，不同的handler编写不同的代码。</p><p>​        这样的问题是很明显的，分支判断复杂，代码庞大，不符合单一职责原则。如果要增加一种handler类型，需要修改代码增加分支处理，违反了开闭原则。DispatcherServelt与多个handler发生了交互，违反迪米特法则。</p><p>​        而使用适配器模式，就可以很好的解决这个问题：</p><p>​        不直接对handler进行处理，而是将handler交给适配器HandlerAdapter去处理，这样DispatcherServlet交互的类就只剩下一个接口，HandlerAdapter，符合迪米特法则，尽可能少的与其他类发生交互；</p><p>​        将handler交给HandlerAdapter处理后，不同类型的handler被对应类型的HandlerAdapter处理，每个HandlerAdapter都只完成单一的handler处理，符合单一职责原则；</p><p>​        如果需要新增一个类型的handler，只需要新增对应类型的HandlerAdapter就可以处理，无需修改原有代码，符合开闭原则。</p><p>​        这样，不同的handler的不同处理方式，就在HandlerAdapter中得到了适配，对于DispatcherServlet来讲，只需要统一的调用HandlerAdapter的handle()方法就可以了，无需关注不同handler的处理细节。</p><p>设计模式的原则<br>    1.单一职责原则<br>        一个类只完成单一的功能，粒度越小越好</p><p>​    2.开闭原则<br>​        对扩展开放，对修改关闭。<br>​        一个类开发完成后，应当可以通过扩展的方式实现新的功能，而不是通过修改原有类来达到目的。</p><p>​    3.里氏替换原则<br>​        所有引用父类的地方都可以透明的使用其子类</p><p>​    4.依赖倒置原则<br>​        抽象不应该依赖于细节，细节应该依赖于抽象。<br>​        应该针对接口或抽象类编程，而不是针对具体的实现编程</p><p>​    5.接口隔离原则<br>​        接口的划分应该更细致，使用多个功能单一的接口，而不是将所有的功能放到一个接口中实现，客户端不应该去依赖它所不需要的接口方法。</p><p>​    6.迪米特法则<br>​    一个类应尽可能少的与其他类进行交互。降低耦合。</p><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adapter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC流程</title>
      <link href="/ckce9unvr000mpkvmffrw9rqt/"/>
      <url>/ckce9unvr000mpkvmffrw9rqt/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC执行流程</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringMVC用到的jar包--&gt;</span><br><span class="line">   &lt;!--spring-web提供监听器--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC对的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><p>当请求进来，执行 DispatcherServlet.doDispatch(HttpServletRequest request，HttpServletResponse response)方法，列举一些比较重要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Determine handler for the current request. 获取handler，返回HandlerExecutionChain执行链</span></span><br><span class="line">        mappedHandler = getHandler(processedRequest);</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// Determine handler adapter for the current request. 获取适配器</span></span><br><span class="line">        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Actually invoke the handler. 根据适配器，执行目标方法</span></span><br><span class="line">        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>HandlerMapping为处理器映射器，由DispathcerServlet调用getHandler(processedRequest)方法，最终返回HandlerExecutionChain执行链，里面包括处理器handler，拦截器filter等等</p><ol><li>HandlerMapping是根据请求URl查找Handler，SpringMVC默认的HandlerMapping在文章后面</li><li>若寻找到handler，将其封装到HandlerExecutionChain返回</li><li>若寻找不到handler，看是否配置了 &lt;mvc:default-servlet-handler /&gt;  标签，若没配置，则直接返回404，并且控制台打印：WARN  ework.web.servlet.PageNotFound  - No mapping for GET /account/test</li><li>若配置了&lt;mvc:default-servlet-handler /&gt;  标签，则使用默认的HandlerMapping：<strong>SimpleUrlHandlerMapping **，返回HandlerExecutionChain执行链，里面的handler为：org.springframework.web.servlet.resource.</strong>DefaultServletHttpRequestHandler**。接着会去寻找静态资源，若找不到就404</li></ol></li><li><p>接下来确定当前请求的处理程序适配器，根据handler去确定适配器，getHandlerAdapter(mappedHandler.getHandler())，默认的HandlerMapping在文章后面</p></li><li><p>到执行处理请求的方法：ha.handle</p><ol><li>先执行拦截器的preHandler方法</li><li>调用目标Handler的目标方法得到返回值ModelAndView对象，反射执行方法看是否存在异常<ol><li>如果存在异常，则由HandlerExceptionResolver组件处理异常，得到新的ModelAndView对象</li><li>最终由试图解析器ViewResolver组件解析ModelAndView对象得到View</li><li>渲染视图</li><li>调用拦截器的afterCompletion方法</li></ol></li><li>调用拦截器的postHandler方法</li></ol></li></ol><h2 id="SpringMVC-默认的映射器以及适配器"><a href="#SpringMVC-默认的映射器以及适配器" class="headerlink" title="SpringMVC 默认的映射器以及适配器"></a>SpringMVC 默认的映射器以及适配器</h2><p>默认的处理器映射器HandlerMapping：        </p><ul><li>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerMapping</strong></li><li>org.springframework.web.servlet.handler.<strong>BeanNameUrlHandlerMapping</strong></li><li>org.springframework.web.servlet.handler.<strong>SimpleUrlHandlerMapping</strong>（注意: 该映射器HandlerMapping是配置 &lt;mvc:default-servlet-handler /&gt; 标签, 返回默认的<strong>DefaultServletHttpRequestHandler</strong>, 如果DispatcherServlet没用找到请求对应的处理器, 则会返回这个handler, 这个handler可以对静态资源进行处理）</li></ul><p>默认的处理器适配器Adapter，主要的作用是执行处理请求的方法：</p><ul><li><p>org.springframework.web.servlet.mvc.<strong>HttpRequestHandlerAdapter</strong></p></li><li><p>org.springframework.web.servlet.mvc.<strong>SimpleControllerHandlerAdapter</strong></p></li><li><p>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerAdapter</strong></p></li></ul><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速返回上次查看代码的位置</title>
      <link href="/ckce9unvs000npkvm3f6qg87u/"/>
      <url>/ckce9unvs000npkvm3f6qg87u/</url>
      
        <content type="html"><![CDATA[<p>快速返回上次查看代码的位置</p><a id="more"></a><h2 id="快速返回上次查看代码的位置"><a href="#快速返回上次查看代码的位置" class="headerlink" title="快速返回上次查看代码的位置"></a>快速返回上次查看代码的位置</h2><h3 id="在IDEA中可以使用快捷键返回，默认是：ctrl-alt-方向键"><a href="#在IDEA中可以使用快捷键返回，默认是：ctrl-alt-方向键" class="headerlink" title="在IDEA中可以使用快捷键返回，默认是：ctrl + alt + 方向键"></a>在IDEA中可以使用快捷键返回，默认是：ctrl + alt + 方向键</h3><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aop</title>
      <link href="/ckce9unvl000gpkvmhigfbfcs/"/>
      <url>/ckce9unvl000gpkvmhigfbfcs/</url>
      
        <content type="html"><![CDATA[<p>aop定义及源码</p><a id="more"></a><h2 id="什么是aop？"><a href="#什么是aop？" class="headerlink" title="什么是aop？"></a>什么是aop？</h2><p>​        与00P对比，面向切面,传统的00P开发中的代码逻辑是至上而下的,在这些至上而下的过程中会产生一些横切性的问题 ,这些横切性的问题和我们的主业务逻辑关系不大,会散落在代码的各个地方,造成难以维护, AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>日志记录</li><li>权限认证</li><li>效率检查</li><li>事务管理</li><li>............</li></ul><p>横切性问题：相对于oop而言，一些跟业务逻辑没有关系，会散落再业务逻辑的各个地方这些代码，这些会造成代码很难维护。</p><p>oop跟多关注的是业务逻辑的处理，而aop关注的是切面的处理</p><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean生命周期源码</title>
      <link href="/ckce9unvc000dpkvmgyvuhzaz/"/>
      <url>/ckce9unvc000dpkvmgyvuhzaz/</url>
      
        <content type="html"><![CDATA[<p>bean生命周期源码</p><a id="more"></a><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类的实例化顺序</title>
      <link href="/ckce9unx6001npkvm3h4o5aga/"/>
      <url>/ckce9unx6001npkvm3h4o5aga/</url>
      
        <content type="html"><![CDATA[<p>类的实例化顺序？</p><a id="more"></a><h2 id="java类的实例化顺序"><a href="#java类的实例化顺序" class="headerlink" title="java类的实例化顺序"></a>java类的实例化顺序</h2><ul><li>1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>4． 父类构造方法</li><li>5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>6． 子类构造方法</li></ul><h3 id="总结：父类静态成员和静态代码块-gt-子类静态成员和静态代码块-gt-父类非静态成员和非静态代码块-gt-父类构造方法-gt-子类非静态成员和非静态代码块-gt-子类构造方法"><a href="#总结：父类静态成员和静态代码块-gt-子类静态成员和静态代码块-gt-父类非静态成员和非静态代码块-gt-父类构造方法-gt-子类非静态成员和非静态代码块-gt-子类构造方法" class="headerlink" title="总结：父类静态成员和静态代码块-&gt;子类静态成员和静态代码块-&gt;父类非静态成员和非静态代码块-&gt;父类构造方法-&gt;子类非静态成员和非静态代码块-&gt;子类构造方法"></a>总结：父类静态成员和静态代码块-&gt;子类静态成员和静态代码块-&gt;父类非静态成员和非静态代码块-&gt;父类构造方法-&gt;子类非静态成员和非静态代码块-&gt;子类构造方法</h3><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket通讯原理</title>
      <link href="/ckce9unw1000tpkvmbb7nefs2/"/>
      <url>/ckce9unw1000tpkvmbb7nefs2/</url>
      
        <content type="html"><![CDATA[<ul><li>什么是TCP/IP、UDP？</li><li>Socket在哪里？</li><li>Socket是什么？</li></ul><a id="more"></a><h2 id="什么是TCP-IP、UDP？"><a href="#什么是TCP-IP、UDP？" class="headerlink" title="什么是TCP/IP、UDP？"></a>什么是TCP/IP、UDP？</h2><p>​        TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p><p>​        这里有一张图，表明了这些协议的关系，如如下图1所示：</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C20180913104811138.jpg" alt="TCP/IP、UDP"></p><p>​        TCP/IP协议族包括运输层、网络层、链路层。现在你知道TCP/IP与UDP的关系了吧。</p><h2 id="Socket在哪里呢？"><a href="#Socket在哪里呢？" class="headerlink" title="Socket在哪里呢？"></a>Socket在哪里呢？</h2><p>​        在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。如下图2所示：</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C2018091310482621.jpg" alt="Socket"></p><h2 id="Socket是什么呢？"><a href="#Socket是什么呢？" class="headerlink" title="Socket是什么呢？"></a>Socket是什么呢？</h2><p>​        Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h2 id="你会使用它们吗？"><a href="#你会使用它们吗？" class="headerlink" title="你会使用它们吗？"></a>你会使用它们吗？</h2><p>​        前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。</p><p>​        例如：一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景解释了这工作原理，也许TCP/IP协议族就是诞生于生活中。</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C20180913104844708.jpg" alt="Socket图解"></p><p>​        先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><hr><p>​        我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页 时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠Socket？那什么是 Socket？Socket的类型有哪些？还有Socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p><h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>​        上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p><h2 id="网络中进程之间是如何通信的？"><a href="#网络中进程之间是如何通信的？" class="headerlink" title="网络中进程之间是如何通信的？"></a>网络中进程之间是如何通信的？</h2><ul><li><p>消息传递（管道、FIFO、消息队列）</p></li><li><p>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</p></li><li><p>共享内存（匿名的和具名的）</p></li><li><p>远程过程调用（Sun RPC）</p></li></ul><p>​        但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程的PID来唯一标识一个进程，但是在网络中这是不可行的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“IP地址”可以表示这个网络中的主机，而传输层的“协议 + 端口”可以唯一表示主机中的应用程序（进程）。这样利用三元组（IP地址、协议、端口）就可表示网络主机的进程，网络中的进程用就可以利用这个标志与其他进程进行交互。</p><p>​        使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（Socket）和UNIX System V的TLI（淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用小恒徐都是采用Socket，而现在又是网络时代，网络中进程通信时无处不在（“一切皆Socket”）。</p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>概念：</p><p>​        TCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p><p>​        它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。</p><p>​        TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。<br> TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”</span><br><span class="line">[Shake 2] 套接字B：“好的，我这边已准备就绪。”</span><br><span class="line">[Shake 3] 套接字A：“发送连接请求。”</span><br></pre></td></tr></table></figure><p>TCP数据报结构，如下图1-1所示：</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C11362584-bf1bffccd9cceaff.webp" alt="TCP数据报结构"></p><p>带阴影的几个字段需要重点说明一下：</p><ul><li>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</li><li>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。</li><li>标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： <ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：建立一个新连接。</li><li>FIN：断开一个连接。</li></ul></li></ul><h3 id="连接的建立（三次握手）：使用-connect-建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2："><a href="#连接的建立（三次握手）：使用-connect-建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2：" class="headerlink" title="连接的建立（三次握手）：使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2："></a>连接的建立（三次握手）：使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图1-2：</h3><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C11362584-75c208edcfb986fc.webp" alt="三次握手"></p><p>​        客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求<br>​         这时客户端发起请求：</p><ul><li>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。</li><li>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包<br> 　服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。<pre><code>　服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。　服务器将数据包发出，进入SYN-RECV状态</code></pre></li><li>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br> 　接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。<pre><code>　客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。</code></pre></li><li>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。<br> 　至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。</li></ul><h3 id="TCP四次握手断开连接"><a href="#TCP四次握手断开连接" class="headerlink" title="TCP四次握手断开连接"></a>TCP四次握手断开连接</h3><p>​        建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。<br> 断开连接需要四次握手，可以形象的比喻为下面的对话：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”</span><br><span class="line">[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”</span><br><span class="line">等待片刻后……</span><br><span class="line">[Shake 3] 套接字B：“我准备好了，可以断开连接了。”</span><br><span class="line">[Shake 4] 套接字A：“好的，谢谢合作。”</span><br></pre></td></tr></table></figure><p>下图演示了客户端主动断开连接的场景：</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C11362584-63aad9661131a2a8.webp" alt="客户端主动断开连接"></p><p>​        建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：</p><ul><li><p>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p></li><li><p>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。<br> 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p></li><li><p>客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</p></li><li><p>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</p></li><li><p>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</p></li><li><p>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</p></li></ul><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a><strong>OSI模型</strong></h3><p>TCP/IP对OSI的网络模型层进行了划分如下：</p><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C11362584-d6275ac25abac5cc.webp" alt="网络模型层"></p><p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中</p><ul><li>应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</li><li>传输层：TCP，UDP</li><li>网络层：IP，ICMP，OSPF，EIGRP，IGMP</li><li>数据链路层：SLIP，CSLIP，PPP，MTU</li><li>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</li></ul><p><img src="C:%5CUsers%5CYuqiang%5CDesktop%5Cblog-master%5Csource_posts%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%5C11362584-2d26013c75ee45e1.webp" alt></p><h3 id="参考文章链接："><a href="#参考文章链接：" class="headerlink" title="参考文章链接："></a>参考文章链接：</h3><ul><li><a href="https://blog.csdn.net/jiushimanya/article/details/82684525" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/jiushimanya/article/details/82684525</a></li><li><a href="https://www.jianshu.com/p/066d99da7cbd" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/066d99da7cbd</a></li></ul><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 中的几种基本数据类型</title>
      <link href="/ckce9unx9001rpkvmhihdee74/"/>
      <url>/ckce9unx9001rpkvmhihdee74/</url>
      
        <content type="html"><![CDATA[<p>JAVA 中的几种基本数据类型是什么，各自占用多少字节。 </p><a id="more"></a><h2 id="Java共有8中基本数据类型"><a href="#Java共有8中基本数据类型" class="headerlink" title="Java共有8中基本数据类型"></a>Java共有8中基本数据类型</h2><table><thead><tr><th>基本数据类型</th><th>占用空间</th></tr></thead><tbody><tr><td>boolean</td><td>1/8个字节（1bit）</td></tr><tr><td>byte</td><td>1个字节</td></tr><tr><td>short</td><td>2个字节</td></tr><tr><td>char</td><td>2个字节</td></tr><tr><td>int</td><td>4个字节</td></tr><tr><td>float</td><td>4个字节</td></tr><tr><td>long</td><td>8个字节</td></tr><tr><td>double</td><td>8个字节</td></tr></tbody></table><p>其中：</p><ul><li>bit（位）：位是计算机中存储数据的最小单位，指二进制数中的一个位数，其值为“0”或“1”</li><li>byte（字节）：字节是计算机存储容量的基本单位，一个字节由8位二进制数组成。在计算机内部，一个字节可以表示一个数据，也可以表示一个英文字母，两个字节可以表示一个汉字</li></ul><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS setTimeout</title>
      <link href="/ckce9unvp000ipkvm9hnv84j3/"/>
      <url>/ckce9unvp000ipkvm9hnv84j3/</url>
      
        <content type="html"><![CDATA[<p>使用循环时，用来延迟执行方法</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_this.data.imgs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 采用闭包的方式来立即执行setTimeout，每隔500毫秒执行方法</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _this.uploadImg(e);</span><br><span class="line">        &#125;, index * <span class="number">500</span>);</span><br><span class="line">    &#125;)(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList与LinkedList</title>
      <link href="/ckce9unx0001ipkvm8ysqalj4/"/>
      <url>/ckce9unx0001ipkvm8ysqalj4/</url>
      
        <content type="html"><![CDATA[<p>ArrayList与LinkedList主要区别</p><a id="more"></a><p>ArrayList底层结构是<strong>数组</strong></p><p>LinkedList底层结构是<strong>链表</strong></p><p>所以主要区别是<strong>数组与链表的区别</strong></p><h3 id="ArrayList：基于数组数据结构"><a href="#ArrayList：基于数组数据结构" class="headerlink" title="ArrayList：基于数组数据结构"></a>ArrayList：基于数组数据结构</h3><ul><li>查询快，在堆（heap）内存是连续的内存空间支持随机访问</li><li>插入和删除的效率比较低，插入需要扩容，删除需要移动元素</li><li>根据内容查找元素的效率较低</li></ul><h3 id="LinkedList：基于链表数据结构"><a href="#LinkedList：基于链表数据结构" class="headerlink" title="LinkedList：基于链表数据结构"></a>LinkedList：基于链表数据结构</h3><ul><li>插入和删除的效率高，非常适合经常增加、删除操作的场景</li><li>查询在量大的时候较慢，链表查询，需要从表头或者表尾逐一遍历查询</li></ul><h3 id="共同点都不是线程安全的"><a href="#共同点都不是线程安全的" class="headerlink" title="共同点都不是线程安全的"></a>共同点都不是线程安全的</h3><h3 id="如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍"><a href="#如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍" class="headerlink" title="如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍"></a>如果想用ArrayList又想线程安全，可以用Vector：底层跟ArrayList一样是数组，但有一点区别，它所有的方法都是被synchronized关键字所修饰，并且扩容大小是2倍</h3><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/ckce9unx3001lpkvmhnr4ct02/"/>
      <url>/ckce9unx3001lpkvmhnr4ct02/</url>
      
        <content type="html"><![CDATA[<p>LinkedList实现原理</p><a id="more"></a><h1 id="阅读本篇文章需要数据结构-链表（双向链表）-的基础"><a href="#阅读本篇文章需要数据结构-链表（双向链表）-的基础" class="headerlink" title="阅读本篇文章需要数据结构 链表（双向链表） 的基础"></a>阅读本篇文章需要数据结构 链表（双向链表） 的基础</h1><p>如何简单使用，创建一个LinkedList对象，并且调用add方法新增一个元素</p><h2 id="先来看看不指定插入的位置"><a href="#先来看看不指定插入的位置" class="headerlink" title="先来看看不指定插入的位置"></a>先来看看不指定插入的位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    list.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就这么两句话，它运行时是如何实现的呢？</p><p>点击进去看源码！</p><ul><li>构造器，并没有执行任何的操作，只是构造一个空链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>add方法，看到方法称以及注释，可知道新增节点采用的是尾插法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再看具体任何新增节点的细节，进去看看linkLast方法</li><li>这是一个很标准的尾插法操作：先将尾节点的引用赋值给 l ，然后创建一个新节点，该节点的前驱（prev）为 l ，数据（item）为 e ，后继（next）为null</li><li>接下来判断该新增节点是否为链表的第一个节点，如果是，则将该节点的引用赋值给 first ，否则将新增节点地址赋值给l.next</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Links e as last element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再看看指定插入的位置"><a href="#再看看指定插入的位置" class="headerlink" title="再看看指定插入的位置"></a>再看看指定插入的位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment">* Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment">* subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先执行checkPositionIndex，校验index是否合法，具体实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tells if the argument is the index of a valid position for an</span></span><br><span class="line"><span class="comment">* iterator or an add operation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后回判断插入的位置是否为尾节点，如果是则执行上面所说的尾插法，否则执行linkBefore方法，需要参数（E e, Node<e> succ），而所需要的 succ 形参需要调用node方法获取到。</e></li><li>看node方法，根据index（索引）获取到所对应的节点。判断的方法类似二分查找法，链表查找都需要逐一遍历，所以需要判断从头节点还是尾节点开始遍历查找。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接下来看linkBefore方法，这个也是双向链表基本的操作。</p><p><img src="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png" alt="双向链表插入某个位置"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/ckce9unwz001hpkvm0y4md2ra/"/>
      <url>/ckce9unwz001hpkvm0y4md2ra/</url>
      
        <content type="html"><![CDATA[<p>ArrayList实现原理</p><a id="more"></a><hr><h2 id="如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素"><a href="#如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素" class="headerlink" title="如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素"></a>如何简单使用，创建一个ArrayList对象，并且调用add方法新增一个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就这么两句话，它运行时是如何实现的呢？</p><p>点击进去看源码！</p><h3 id="当不指定数组长度时"><a href="#当不指定数组长度时" class="headerlink" title="当不指定数组长度时"></a>当不指定数组长度时</h3><ul><li><p>构造器（构造函数）：此构造器没有参数，并且也没有数组初始化，就只有一句 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。问题来了，是什么时候开始初始化数组？初始化的长度是多少？带着这个问题，继续往下面看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当调用add方法时，点击进去查看源代码，在真正赋值的操作前，执行了ensureCapacityInternal，参数是 size + 1 ，size表示当前ArrayList的大小，此参数的意义是判断 size + 1 后，数组索引是否越界，所以这个方法是保证在赋值前数组索引是否越界（是否需要扩容）以及记录ArrayList结构性变化的次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在赋值前，记录modCount（modCount，记录ArrayList结构性变化的次数）以及判断是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>点进去ensureCapacityInternal方法，上来就一个判断，这个判断是什么意思？回过头来看一下空构造器，这句话不就是判断的条件吗？</p></li><li><p>构造器出现的 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;那么它是什么意思呢？按照字面意思是表示一种状态，当 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表采用默认的长度 DEFAULT_CAPACITY （10），以确保在第一次添加元素时要扩容的大小。</p></li><li><p>判断条件成立，执行Math.max，在DEFAULT_CAPACITY（10）和minCapacity（1）之间取最大值，以确保在第一次添加元素时要扩容的大小，获取到最大值后将它赋值给minCapacity（10），接着执行ensureExplicitCapacity方法并传入参数minCapacity，具体往后面看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Default initial capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">* distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">* first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续来看看ensureExplicitCapacity方法源码，上来就modCount++，表示ArrayList结构性变化的次数加一，接着判断数组索引是否越界（是否需要扩容）。此时，当创建ArrayList对象时，只是初始化空数组，并没有指定数组长度，所以elementData.length = 0，而minCapacity是传过来的参数10，所以该判断条件是成立的，需要执行grow方法进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里需要注意的是：minCapacity = 10，elementData.length = 0。这里不理解的还需要再回到前面去看看。</p></li><li><p>当执行到扩容语句时，此时的elementData.length = 0，所以扩容之后还是0，这个时候就有疑问了，扩容之后还是0？接下来的一个判断起到关键性的作用，也是专门判断扩容之后的长度比原来小的问题，当扩容后的长度比原先的小时，最终是按照原先的大小进行扩容，再下面就是数组copy扩容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">* number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 这里确定扩容的大小，比原来大1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>刚开始写的博客，可能表达的有点不清楚，请见谅</strong></p><blockquote><h4 id="总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1-5倍。"><a href="#总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1-5倍。" class="headerlink" title="总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1.5倍。"></a>总结：在不指定数组长度的前提下，创建ArrayList对象时，并不会随着ArrayList对象的创建而马上初始化数组，而是先赋值一个空数组，当add第一个元素时，才会进行初始化数组，并且默认数组的长度为10，扩容容量为1.5倍。</h4></blockquote><h2 id="当指定数组长度："><a href="#当指定数组长度：" class="headerlink" title="当指定数组长度："></a>当指定数组长度：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><blockquote><h4 id="结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10"><a href="#结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10" class="headerlink" title="结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10."></a>结论：这个时候会执行的构造器，与不指定长度的构造器有明显的区别，当指定长度，创建ArrayList对象时，会随着ArrayList对象的创建而初始化数组，而默认长度的构造器是在第一次add元素时才初始化数组，并且长度时10.</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">*         is negative</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer与StringBuilder</title>
      <link href="/ckce9unx4001mpkvmbjkb5eaf/"/>
      <url>/ckce9unx4001mpkvmbjkb5eaf/</url>
      
        <content type="html"><![CDATA[<p>StringBuffer与StringBuilder主要的区别</p><a id="more"></a><hr><h2 id="话不多说，先先看源码（JDK1-8）"><a href="#话不多说，先先看源码（JDK1-8）" class="headerlink" title="话不多说，先先看源码（JDK1.8）"></a>话不多说，先先看源码（JDK1.8）</h2><p>StringBuffer类的append方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder类的append方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显可以看出，<strong>StringBuffer类的append方法被synchronized关键字修饰，而StringBuilder类的append方法没有被synchronized修饰。</strong></p><p><strong>Tips：被synchronized修改的方法或者代码块可以保证在同一时刻，只有一个线程可以执行，同时还可以保证线程的可见性</strong>。</p><h2 id="结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。"><a href="#结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。" class="headerlink" title="结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。"></a>结论：StringBuffer时线程安全的（所有方法都加上了synchronized关键字），StringBuilder时线程不安全的，但是StringBuilder的效率远比StringBuffer快。</h2><h2 id="String是字符串不可变对象-StringBuffer、StringBuild-可变对象-StringBuffer线程安全-其中方法用synchronized修饰"><a href="#String是字符串不可变对象-StringBuffer、StringBuild-可变对象-StringBuffer线程安全-其中方法用synchronized修饰" class="headerlink" title="String是字符串不可变对象, StringBuffer、StringBuild,可变对象 StringBuffer线程安全,其中方法用synchronized修饰"></a>String是字符串不可变对象, StringBuffer、StringBuild,可变对象 StringBuffer线程安全,其中方法用synchronized修饰</h2><p>除了synchronized关键字外，StringBuffer类还多了个<strong>toStringCache</strong>成员变量，这个变量是干什么的呢？来看一下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">* whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从官方字面意思来说是返回最后一次toString的缓存值，一但被修改就清除这个值。</p><p>当多个线程同时访问时，StringBuffer虽然是线程安全的，但是性能低效，所以加一个缓存来平衡一下StringBuffer的性能。</p><hr><br><br><span class="btn large center"><a href="<https://github.com/itqiangyu/itqiangyu.github.io/issues>" title="向博主反馈问题"><i class="fas fa-paper-plane"></i>向博主反馈问题</a></span>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/ckce9unv9000bpkvm8vlh2he9/"/>
      <url>/ckce9unv9000bpkvm8vlh2he9/</url>
      
        <content type="html"><![CDATA[<p>MarkDown语法基本语法</p><a id="more"></a><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题:"></a>标题:</h2><p>#空格：一级标题<br>##空格：二级标题<br>###空格：三级标题<br>####空格：四级标题<br>#####空格：五级标题<br>######空格：六级标题</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>两边各加两个 * 是粗体</strong></p><p><em>两边各加一个 * 是斜体</em></p><p><strong><em>两边各加三个 * 是粗体加斜体</em></strong></p><p><del>两边各加两个 ~ 波浪线</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>&quot;&gt;&quot; 空格</p><p>例如：</p><blockquote></blockquote><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个&quot;---&quot;或者&quot;***&quot;是分割线</p><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>!加[]加()是添加图片,可以添加本地路径或网络图片地址</p><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[]加()括号里面下网络地址</p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>1点空格（1. ）：是以下列表</li></ul><ol><li>A</li><li>B</li><li>C</li></ol><ul><li><p>-空格：是以下列表</p></li><li><p>A</p></li><li><p>B</p></li><li><p>C</p></li></ul><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>例如：下面三行，删掉换行就是表格</p><p>名字|性别|生日</p><p>--|--|--|</p><p>张三|男|1994.1.1</p><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1994.1.1</td></tr></tbody></table><hr><br><br><span class="btn large center"><a href="https://github.com/itqiangyu/itqiangyu.github.io/issues" target="_blank" rel="external nofollow noopener noreferrer" title="联系博主"><i class="fas fa-paper-plane"></i>联系博主</a></span>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http与https的区别</title>
      <link href="/ckce9unvz000rpkvm2xr75v91/"/>
      <url>/ckce9unvz000rpkvm2xr75v91/</url>
      
        <content type="html"><![CDATA[<p>基本概念和主要区别</p><a id="more"></a><h3 id="HTTP与HTTPS的基本概念"><a href="#HTTP与HTTPS的基本概念" class="headerlink" title="HTTP与HTTPS的基本概念"></a>HTTP与HTTPS的基本概念</h3><ul><li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li><li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li><li>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</li></ul><h3 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h3><ul><li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><hr><p>参考文章：<a href="https://www.jianshu.com/p/6db0c6dc97a9" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/6db0c6dc97a9</a><br><br><br><span class="btn large center"><a href="https://github.com/itqiangyu" target="_blank" rel="external nofollow noopener noreferrer" title="联系博主"><i class="fas fa-paper-plane"></i>联系博主</a></span></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/ckce9uns50004pkvm6bheg9lv/"/>
      <url>/ckce9uns50004pkvm6bheg9lv/</url>
      
        <content type="html"><![CDATA[<p>2020/6/4 搭建hexo博客</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/ckce9unrx0002pkvm0oava0li/"/>
      <url>/ckce9unrx0002pkvm0oava0li/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
